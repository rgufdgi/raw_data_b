raw_data
Программа сортирует сырой файл по gir и в большинстве случаев по rf. Создаются 
соответствующие csv-файлы с помощью pandas. Таблицы pandas очень медленно работают
в циклах, поэтому создаются в уже конце, для проверки правильности работы программы
и для, собственно, записи данных в новые файлы.

При чтении данных значения (состоящие из какого-то своего числа байтов) идут в 
правильной последовательности, байты внутри них -- в обратной. Для преобразования
ко всем значениям длиной больше байта применяется функция rverse. Функции u124, 
i124 и floatt преобразуют последовательности байтов в соответствующие числа. Они
в свою очередь пользуются функцией hex_to_binary, которая переводит считанное
шестнадцатиричное число в двоичное, добавляя нужное число нулей в начало (чтобы не 
было проблем с, например, знаковыми типами данных).

name -- название файла. (i****_0Y.**** буква -- год (i -- 2019, n -- 2024), номер
рана, Y -- номер кластера, номер файла в ране). При чтении файла заполняются списки 
общей структуры, потом основной цикл проходится по их длине, заполняя словари для
данных с разными gir и rf. Для мастерных данных (gir 6) написаны свои функции, 
возвращающие словари, аналогичные основным словарям, которые добавляются в них 
в основном цикле. Опреции для других записей выполняются прямо в цикле.

Список дел/проблем/неочевидных(мне)особенностей:
* local_time выглядит очень странно
* куски кода, сортирующие всё, кроме мастерных записей, не проверялись на деле
(в моих файлах не было таких записей), скорее всего, там много ошибок и опечаток
* часть записей, не относящихся к мастерным (не gir 6) не переводит / 
переводит не до конца последовательности байтов в значения. В особенности:
* Скорее всего, будет много проблем в конфигурации детектора из-за разных версий.
Сейчас код отделят друг от друга адресную, статическую и динамическую конфигурации,
но они остаются в виде строк с последовательностью байтов.
*странные значения quality

# исправлены сообщения об ошибках. Не исправлены. Программа удалилась к чертям.

raw_06
тут начало программы по обработке получившихся временных кадров




Для какого-то грубого анализа я написала функцию, которая возвращает значение 
импульса АЦП в его середине (обозначено в программе как y). В принципе, можно 
возвращать максимум импульса, но так надо переводить все числа из двоичного кода, 
и мне лень переделывать.

Я построила графики для каждого файла из лазерного рана 13-го кластера, и две 
картинки по половине файлов для рана на 10 кластере. (на них какие-то странные
 значения времени). По всему списку, без какой-либо сортировки по секциям.

На графиках 12 полосок с разным сигналом, видимо, это разные ОМ. Надо повторить 
это для какого-нибудь мюонного рана. 

На кадрах для 13-го кластера при работе лазера полоска ОМ раздваивается. !На первых 
двух файлах нет раздвоения, на всех остальных -- где видно лазер и нет -- раздвоение
есть. На двух общих картинках для 10-го кластера раздвоения не видно.

По графикам я смотрела, на каких файлях видны лазерные события.
(это файлы 9 -- 19).

raw_06_2
Тут я построила графики с сортировкой по секциям --- три графика по 9 картинок, 
на каждой по три гирлянды. По ним я смотрела, в каких файлах и на каких секциях видны 
лазеры. Тут видно, что "раздвоения" происходят при работе лазера.


Из этих графиков я определила, на каких секциях в каких файлах видны лазеры,
и сделала таблички для каждой секции отдельно с нужными файлами.

raw_06_3
Построение графиков для каждого ОМ. Не знаю, зачем такие. Кажется, это не очень умно.
Ещё графики для секций.


конец августа
какие-то штуки для удобства
raw_data
мастерные данные -- я оставляю только следующие значения ключей словаря с данными:
om, sdc. step, values, time, timet, event_n.
я пересохранила данные для 10-го кластера

raw_06
теперь вместо середины дорожки сохраняется значение максимума